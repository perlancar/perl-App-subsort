#!perl

## no critic: (InputOutput::ProhibitReadlineInForLoop)

# AUTHORITY
# DATE
# DIST
# VERSION

use 5.010001;
use strict 'subs', 'vars';
use warnings;

use Complete::Util qw(arrayify_answer);
use Getopt::Long::More;
use Sort::Sub ();

my %opts = (
    ignore_case => 0,
    reverse => 0,
);
my $routine;
my $routine_args = {};
my @files;
my $res = GetOptions(
    'ignore_case|f' => sub { $opts{ignore_case} = 1 },
    'reverse|r'     => sub { $opts{reverse} = 1 },
    'help|h'        => sub {
        print <<'_';
sortsub - Sort lines of text using Sort::Sub routines

Usage:
  % subsort [OPTIONS] <ROUTINE> [FILE]...
  % subsort --help (or -h)
  % subsort --list (or -l)
  % subsort --version (or -v)

Options:
  --help, -h         Show this help message and exit.
  --version, -v      Show version and exit.
  --list, -l         List available Sort::Sub routines.
  --ignore-case, -f  Do a case-insensitive sort.
  --reverse, -r      Do a reverse sort.
  --arg=s, -A        Argument to pass to sorter. In the form of name=val. Can
                       be specified multiple times.
_
        exit 0;
    },
    'version|v'     => sub {
        no warnings 'once';
        say "subsort version ", ($main::VERSION // 'dev'),
            " (", ($main::DATE // 'no date'), ")";
        exit 0;
    },
    'list|l'        => sub {
        require Module::List::Tiny;
        my $mods = Module::List::Tiny::list_modules(
            "Sort::Sub::", {list_modules=>1});
        for (sort keys %$mods) {
            s/.+:://;
            say $_;
        }
        exit 0;
    },
    '<>' => optspec(
        handler => sub {
            my $val = shift;
            if (!defined $routine) {
                $routine = $val;
            } else {
                push @files, $val;
            }
        },
        completion => sub {
            my %args = @_;
            if ($args{argpos} == 0) {
                require Complete::Module;
                Complete::Module::complete_module(
                    word => $args{word},
                    ns_prefix => "Sort::Sub",
                );
            } else {
                require Complete::File;
                Complete::File::complete_file(
                    word => $args{word},
                );
            }
        },
    ),
    'arg|A=s' => optspec(
        handler => sub {
            my $val = $_[1];
            die "subsort: Invalid syntax in --arg (-A), please use name=val: $val\n"
                unless $val =~ /(.+?)=(.*)/;
            $routine_args->{$1} = $2;
        },
        completion => sub {
            require Complete::Sequence;
            my %args = @_;

            my $compres;

            # do we have the routine already? if yes, extract the metadata
            my $rname;
            {
                $rname = $routine;
                last if defined $rname;
                $rname = $args{words}[0] if @{ $args{words} };
            }
            return [] unless defined $rname;

            my $mod = "Sort::Sub::$rname";
            (my $mod_pm = "$mod.pm") =~ s!::!/!g;
            eval { require $mod_pm };
            return {message=>"Cannot load $mod: $@"} if $@;
            my $meta;
            eval { $meta = $mod->meta };
            return [] unless $meta;

            return Complete::Sequence::complete_sequence(
                word => $args{word},
                sequence => [
                    sub {
                        [$meta->{args} ? keys(%{ $meta->{args} }) : ()];
                    },
                    '=',
                    sub {
                        my $stash = shift;
                        my $argname = $stash->{completed_item_words}[0];
                        return [] unless defined $argname;

                        my $argspec = $meta->{args}{$argname};
                        return [] unless $argspec->{schema};

                        require Complete::Sah;
                        arrayify_answer(
                            Complete::Sah::complete_from_schema(
                                word => $stash->{cur_word},
                                schema => $argspec->{schema},
                            )
                        );

                    },
                ],
            );

          RETURN_COMPRES:
            return $compres;
        }, # completion for 'arg'
    ),
);
exit 1 unless $res;

die "subsort: Please specify routine to use\n" unless defined $routine;

$routine = Sort::Sub::get_sorter(
    "$routine<".
        ($opts{ignore_case} ? "i":"").
        ($opts{reverse} ? "r":"").
        ">",
    $routine_args,
);
@ARGV = @files;
for (sort {&{$routine}} map {chomp;$_} <>) {
    say $_;
}

# ABSTRACT: Sort lines of text using Sort::Sub routines
# PODNAME:

=head1 SYNOPSIS

 % subsort [OPTIONS] <ROUTINE> [FILE]...

To list all available routines:

 % subsort -l


=head1 DESCRIPTION

This program is like the Unix command B<sort>, but it uses routines from
L<Sort::Sub>.


=head1 OPTIONS

  --help, -h         Show this help message and exit.
  --version, -v      Show version and exit.
  --list, -l         List available Sort::Sub routines.
  --ignore-case, -f  Do a case-insensitive sort.
  --reverse, -r      Do a reverse sort.
  --arg=s, -A        Argument to pass to sorter. In the form of name=val. Can
                       be specified multiple times.


=head1 SEE ALSO

The B<sort> Unix command.

L<App::psort>

L<Sort::Sub>, which also provides sorting functionality to various other CLI's
e.g. L<sorted> (from L<App::sorted>)).

=cut
